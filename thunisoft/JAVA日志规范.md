# JAVA日志规范

## 1、整体说明

业务系统中，我们需要尽可能**记录所有信息**，以便观察系统运行的状态，追踪、排查线上问题。

```
在开发系统时，对于日志，我们需要关注：
日志信息的集中采集、存储、信息检索：在WEB集群节点越来越多的情况下，让开发及系统维护人员能很方便的查看日志信息
日志信息的输出策略：日志信息输出全而不乱，便于跟踪和分析问题
关键业务的日志输出：基于度量数据采集、数据核查、系统安全等方面的考虑，关键业务系统对输出的日志信息有特殊的要求，需要做针对性的设计
```



本文档只关注“2.日志信息的输出策略”、“3.业务系统的日志输出”



## 2、日志信息输出策略

### 	2.1、日志输出级别

每次创建日志记录语句时，你都会认真思考哪种日志记录级别适合此类事件，是吗？不知何故，有90％的程序员从不关注日志记录级别，仅将**所有内容**记录在同一级别上，通常是ERROR或DEBUG。为什么？与System.out相比，日志记录框架有两个主要优点：类别和级别。两者都允许您有选择地永久性地或仅在诊断时间内选择性地过滤日志记录语句。如果您真的看不到它们之间的区别，请在每次在输出日志的时候仔细查看注释。

- **ERROR**：系统中发生了非常严重的问题，严重影响了系统的使用，必须马上有人进行处理。
  没有系统可以忍受这个级别的问题的存在。比如：Null Point Exception（空指针异常），数据库连接失败，关键业务流程中断。
- **WARN**：发生这个级别问题时，系统还可以正常使用，但必须对这个问题给予额外关注。
  这个问题又可以细分成两种情况：一种是存在严重的问题但有应急措施（比如数据库不可用，使用缓存）；第二种是潜在问题及建议，比如生产环境的应用运行在Development模式下、管理控制台没有密码保护等。系统可以允许这种错误的存在，但必须及时做跟踪检查。
- **INFO**：不影响系统的使用。在实际环境中，驻地或者开发要能理解INFO输出的信息并能很快的了解应用正在做什么。比如，一个法院业务系统正在生成文书。另外一种对INFO信息的定义是：记录显著改变应用状态的每一个阶段，比如：数据库更新、外部系统请求进入。
- **DEBUG**：用于开发人员使用。将在TRACE中一起说明这个级别该输出什么信息。
- **TRACE**：非常具体的信息，只能用于开发调试使用。
  部署到生产环境后，这个级别的信息只能保持很短的时间。这些信息只能临时存在，并将最终被关闭。要区分DEBUG和TRACE会比较困难，对一个在开发及测试完成后将被删除的LOG输出，可能会比较适合定义为TRACE级别。



**推荐使用info，warn，error级别即可**，对于不同的级别可以设置不同的输出路径,如info输出到一个文件，warn，error输出到一个带error后缀的文件。

最好能尽可能输出更多的日志信息，并且不做任何过滤。同时输出的每一条日志的详细信息要切当，让我们可以快速过滤并找到所需的信息。

由于SLF4J具有良好的模式替换机制，可避免保护性日志记录的必要性，从而避免了字符串连接以及不必要的求值和对象实例化

```java
logger.debug("Found {} records matching filter: '{}'", records, filter); 
```

### 2.2、日志输出信息

#### 日志应该记录什么，怎么记录
日志的输出应该遵循RCCD即可读（readable）+ 干净（clean）+ 详细（concise）+ 描述（ descriptive）

在记录每一个日志前，一定要花点时间想想日志中该出现什么信息。并且在事后要多检查一下日志输出，下面是一些不好的例子：

`log.error(e.getMessage,e）`

`log.error(e)`

``` java
try{
    dosomthing();
    ...
}catch(Exception e){
    log.error("出现了异常");
}
```
日志里出现了上述信息是无法定位问题的甚至还会干扰，我们必须要在日志里把问题描述清楚，我们可以参考新闻五要素——何时（when）、何地（where ）、何事（what）、何因（why ）、何人（who ），when：什么时候发生的，主要是写明是在什么操作和场景下发生的;where:发生异常或者记录日志的位置，日志框架会自动记录日志发生的调用堆栈;what:发生了什么异常;why:可以写一个可能的原因，比如配置问题让驻地可以先排查一次;who:有的场景下可以记录操作人这样也有助于驻地排查。

**不要在日志里记录 密码及其他敏感信息**。

#### 记录方法调用、入参及返回值

建议最好别在代码里出现以下日志：

```java
public String printDocument(Document doc, Mode mode) {
    log.debug("Entering printDocument(doc={}, mode={})", doc, mode);
    String id = //Lengthy printing operation
    log.debug("Leaving printDocument(): {}", id);
    return id;
}
```
虽然这样记录可以对于开发人员掌控的环境（无法做DEBUG），记录方法调用、入参、返回值的方式对于排查问题会有很大帮助。但是这样有时候在这个方法调用频率过高的时候可能会影响系统的性能，建议用Arthas、java-agent等工具来获取方法的参数和返回值和调用时间等参数。

#### 关注外部系统

如果是外部系统调用我们系统的日志，那在发生异常之后把接口的参数也打印出来便于排查问题，我们调用其他系统的接口的时候也同理。



## 3.业务系统的日志输出

建议不要把所有日志都放在一个日志文件里，适当的拆分可以帮助你更快的找到问题。像上文说的根据级别来分是一个不错的选择，但是如果系统足够大建议根据业务来拆分，比如把定时任务的放在一个文件里，把外部系统调用我们接口的日志放在一个文件里，普通操作产生的日志放在一个文件里。

## 4.使用适合的`appender`

[logback官方网站](http://logback.qos.ch/manual/appenders.html)上提供了很多种`appender`，请选择最合适的appender



参考文档：

<https://www.nurkiewicz.com/2010/05/clean-code-clean-logs-use-appropriate.html>

<https://www.codeproject.com/Articles/42354/The-Art-of-Logging>

<https://wiki.base22.com/btg/java-logging-standards-and-guidelines-2361.html>