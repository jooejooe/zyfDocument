# Netty学习

## 1、简介

官方定义为：”Netty 是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器 
和客户端”,按照惯例贴上一张架构图：

![](http://bed.thunisoft.com:9000/ibed/2019/07/14/8575ed4266df4eee830c695492a5a479.png)

纵观Java系的多种服务器/大数据框架，都离不开Netty做出的贡献

Netty有很多重要的特性，主要特性如下： 
- 优雅的设计 
- 统一的API接口，支持多种传输类型，例如OIO,NIO 
- 简单而强大的线程模型 
- 丰富的文档 
- 卓越的性能 
- 拥有比原生Java API 更高的性能与更低的延迟 
- 基于池化和复用技术，使资源消耗更低 
- 安全性 
- 完整的SSL/TLS以及StartTLS支持 
- 可用于受限环境，如Applet以及OSGI

Netty的以上特性，比较适合客户端数据较大的请求/处理场景，例如web服务器等，要想知道有哪些系统使用了Netty,可以参考：http://netty.io/wiki/adopters.html

### 1.2 主要术语

NIO和BIO：早期的Java API(java.net)提供了由本地系统套接字库提供的所谓的阻塞函数（BIO），代码如下：

```
ServerSocket serverSocket = new ServerSocket(portNumber);
Socket clientSocket = serverSocket.accept();
BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
PrintWriter out =new PrintWriter(clientSocket.getOutputStream(), true);
String request, response;
while ((request = in.readLine()) != null) {
    if ("Done".equals(request)) {
        break;
}
response = processRequest(request);
out.println(response);
}
```

这段代码片段将只能同时处理一个连接，要管理多个并发客户端，需要为每个新的客户端 
Socket 创建一个新的 Thread,线程模型如下图所示：![](https://img-blog.csdn.net/20180523184142105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bjc1NDU1MjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

该种模型存在以下两个问题： 
1. 在任何时候都可能有大量的线程处于休眠状态，只是等待输入或者输出数据就绪，这可能算是一种资源浪费 
2. 需要为每个线程的调用栈都分配内存 
3. 即使 Java 虚拟机（JVM） 在物理上可以支持非常大数量的线程， 但是远在到达该极限之前， 上下文切换所带来的开销就会带来麻烦

那么我们再来看看所谓的NIO，Java的NIO特性在JDK 1.4中引入，其结构如下：![](https://img-blog.csdn.net/20180523184130551?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bjc1NDU1MjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

从该图可以看出Selector 是Java 的非阻塞 I/O 实现的关键。它使用了事件通知 API 
以确定在一组非阻塞套接字中有哪些已经就绪能够进行 I/O 相关的操作。因为可以在任何的时间检查任意的读操作或者写操作的完成状态。该种模型下，一个单一的线程便可以处理多个并发的连接。 
与BIO相比，该模型有以下特点： 

1. 使用较少的线程便可以处理许多连接，因此也减少了内存管理和上下文切换所带来开销 
2. 当没有 I/O 操作需要处理的时候，线程也可以被用于其他任务

虽然Java 的NIO在性能上比BIO已经相当的优秀，但是要做到如此正确和安全并 

不容易。特别是，在高负载下可靠和高效地处理和调度 I/O 操作是一项繁琐而且容易出错的任务，此时就时Netty上场的时间了。

## 2、Netty介绍

Netty对NIO的API进行了封装，通过以下手段让性能又得到了一定程度的提升 
1. 使用多路复用技术，提高处理连接的并发性 
2. 零拷贝： 
1. Netty的接收和发送数据采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝 
2. Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象进行一次操作 
3. Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题 
3. 内存池：为了减少堆外直接内存的分配和回收产生的资源损耗问题，Netty提供了基于内存池的缓冲区重用机制 
4. 使用主从Reactor多线程模型，提高并发性 
5. 采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降 
6. 默认使用Protobuf的序列化框架 
7. 灵活的TCP参数配置

详细说明，可参考： http://www.infoq.com/cn/articles/netty-high-performance#anch111813

## 3、Netty和传统IO还有NIO的比较

在进行比较之前我们先介绍一下I/O模型：**阻塞IO、非阻塞IO、信号驱动IO、IO多路转接、异步IO**。其中，前四个被称为同步IO。

#### 1.阻塞IO（blocking I/O）

A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。

在内核将数据准备好之前，系统调用会一直等待所有的套接字，默认的是阻塞方式。

其实，我们例子中所说的鱼竿就是这一个文件描述符。这个模型是我们最常见的，程序调用和我们编写的基本程序是一致的。

```
fd=connect();
write(fd);
read(fd);
close(fd);
```

程序的read必须在write之后执行，当write阻塞住了，read就不能执行下去，一直处于等待状态。

#### 2.非阻塞IO（noblocking I/O）

B也在河边钓鱼，但是B不想将自己的所有时间都花费在钓鱼上，在等鱼上钩这个时间段中，B也在做其他的事情（一会看看书，一会读读报纸，一会又去看其他人的钓鱼等），但B在做这些事情的时候，每隔一个固定的时间检查鱼是否上钩。一旦检查到有鱼上钩，就停下手中的事情，把鱼钓上来。其实，B在检查鱼竿是否有鱼，是一个轮询的过程。

每次客户询问内核是否有数据准备好，即文件描述符缓冲区是否就绪。当有数据报准备好时，就进行拷贝数据报的操作。当没有数据报准备好时，也不阻塞程序，内核直接返回未准备就绪的信号，等待用户程序的下一个轮寻。

#### 3.信号驱动IO（signal blocking I/O）

C也在河边钓鱼，但与A、B不同的是，C比较聪明，他给鱼竿上挂一个铃铛，当有鱼上钩的时候，这个铃铛就会被碰响，C就会将鱼钓上来**信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。**

#### 4.IO多路转接（I/O multiplexing）

D同样也在河边钓鱼，但是D生活水平比较好，D拿了很多的鱼竿，一次性有很多鱼竿在等，D不断的查看每个鱼竿是否有鱼上钩。增加了效率，减少了等待的时间。IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。

其中，select只负责等，recvfrom只负责拷贝。 

#### 5.异步IO（asynchronous I/O）

E也想钓鱼，但E有事情，于是他雇来了F，让F帮他等待鱼上钩，一旦有鱼上钩，F就打电话给E，E就会将鱼钓上去。

异步IO的概念和同步IO相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。在一个CPU密集型的应用中，有一些需要处理的数据可能放在磁盘上。预先知道这些数 据的位置，所以预先发起异步IO读请求。等到真正需要用到这些数据的时候，再等待异步IO完成。使用了异步IO，在发起IO请求到实际使用数据这段时间 内，程序还可以继续做其他事情

#### 场景：客户端每隔两秒发送一个带有时间戳的"hello world"给服务端，服务端收到之后打印。

### 传统IO（BIO）：

​	server端首先创建了一个`serverSocket`来监听8000端口，然后创建一个线程，线程里面不断调用阻塞方法 `serversocket.accept();`获取新的连接，见(1)，当获取到新的连接之后，给每条连接创建一个新的线程，这个线程负责从该连接中读取数据，然后读取数据是以字节流的方式。

​	IO编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服务端可能需要支撑成千上万的连接，IO模型可能就不太合适了，我们来分析一下原因。

上面的demo，从服务端代码中我们可以看到，在传统的IO模型中，每个连接创建成功之后都需要一个线程来维护，每个线程包含一个while死循环，那么1w个连接对应1w个线程，继而1w个while死循环，这就带来如下几个问题：

1. 线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起
2. 线程切换效率低下：单机cpu核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。
3. 除了以上两个问题，IO编程中，我们看到数据读写是以字节流为单位，效率不高。

为了解决这三个问题，JDK在1.4之后提出了NIO。

### NIO：

​	NIO编程模型中，新来一个连接不再创建一个新的线程，而是可以把这条连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责，那么他是怎么做到的？我们用一幅图来对比一下IO与NIO

![](https://upload-images.jianshu.io/upload_images/1357217-1c856423372e7d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/755/format/webp)

如上图所示，IO模型中，一个连接来了，会创建一个线程，对应一个while死循环，死循环的目的就是不断监测这条连接上是否有数据可以读，大多数情况下，1w个连接里面同一时刻只有少量的连接有数据可读，因此，很多个while死循环都白白浪费掉了，因为读不出啥数据。

而在NIO模型中，他把这么多while死循环变成一个死循环，这个死循环由一个线程控制，那么他又是如何做到一个线程，一个while死循环就能监测1w个连接是否有数据可读的呢？
 这就是NIO模型中selector的作用，一条连接来了之后，现在不创建一个while死循环去监听是否有数据可读了，而是直接把这条连接注册到selector上，然后，通过检查这个selector，就可以批量监测出有数据可读的连接，进而读取数据，下面我再举个非常简单的生活中的例子说明IO与NIO的区别。

在一家幼儿园里，小朋友有上厕所的需求，小朋友都太小以至于你要问他要不要上厕所，他才会告诉你。幼儿园一共有100个小朋友，有两种方案可以解决小朋友上厕所的问题：

1. 每个小朋友配一个老师。每个老师隔段时间询问小朋友是否要上厕所，如果要上，就领他去厕所，100个小朋友就需要100个老师来询问，并且每个小朋友上厕所的时候都需要一个老师领着他去上，这就是IO模型，一个连接对应一个线程。
2. 所有的小朋友都配同一个老师。这个老师隔段时间询问所有的小朋友是否有人要上厕所，然后每一时刻把所有要上厕所的小朋友批量领到厕所，这就是NIO模型，所有小朋友都注册到同一个老师，对应的就是所有的连接都注册到一个线程，然后批量轮询。

这就是NIO模型解决线程资源受限的方案，实际开发过程中，我们会开多个线程，每个线程都管理着一批连接，相对于IO模型中一个线程管理一条连接，消耗的线程资源大幅减少

#### 线程切换效率低下

由于NIO模型中线程数量大大降低，线程切换效率因此也大幅度提高

#### IO读写以字节为单位

NIO解决这个问题的方式是数据读写不再以字节为单位，而是以字节块为单位。IO模型中，每次都是从操作系统底层一个字节一个字节地读取数据，而NIO维护一个缓冲区，每次可以从这个缓冲区里面读取一块的数据，
 这就好比一盘美味的豆子放在你面前，你用筷子一个个夹（每次一个），肯定不如要勺子挖着吃（每次一批）效率来得高。

简单讲完了JDK NIO的解决方案之后，我们接下来使用NIO的方案替换掉IO的方案，我们先来看看，如果用JDK原生的NIO来实现服务端，该怎么做

解释一下几个核心思路

1. NIO模型中通常会有两个线程，每个线程绑定一个轮询器selector，在我们这个例子中`serverSelector`负责轮询是否有新的连接，`clientSelector`负责轮询连接是否有数据可读
2. 服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到`clientSelector`上，这样就不用IO模型中1w个while循环在死等，参见(1)
3.  `clientSelector`被一个while死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过 `clientSelector.select(1)`方法可以轮询出来，进而批量处理，参见(2)
4. 数据的读写以内存块为单位，参见(3)

其他的细节部分，我不愿意多讲，因为实在是太复杂，你也不用对代码的细节深究到底。总之，强烈不建议直接基于JDK原生NIO来进行网络开发，下面是我总结的原因

1、JDK的NIO编程需要了解很多的概念，编程复杂，对NIO入门非常不友好，编程模型不友好，ByteBuffer的api简直反人类
 2、对NIO编程来说，一个比较合适的线程模型能充分发挥它的优势，而JDK没有给你实现，你需要自己实现，就连简单的自定义协议拆包都要你自己实现
 3、JDK的NIO底层由epoll实现，该实现饱受诟病的空轮训bug会导致cpu飙升100%
 4、项目庞大之后，自行实现的NIO很容易出现各类bug，维护成本较高，上面这一坨代码我都不能保证没有bug

为了解决上述的问题所以就有了Netty

​	Netty封装了JDK的NIO，让你不用再写一大堆复杂的代码了。用官方正式的话来说就是：Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。下面是我总结的使用Netty不使用JDK原生NIO的原因

1. 使用JDK自带的NIO需要了解太多的概念，编程复杂，一不小心bug横飞
2. Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型
3. Netty自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑
4. Netty解决了JDK的很多包括空轮询在内的bug
5. Netty底层对线程，selector做了很多细小的优化，精心设计的reactor线程模型做到非常高效的并发处理
6. 自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手
7. Netty社区活跃，遇到问题随时邮件列表或者issue
8. Netty已经历各大rpc框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大

这么一小段代码就实现了我们前面NIO编程中的所有的功能，包括服务端启动，接受新连接，打印客户端传来的数据，怎么样，是不是比JDK原生的NIO编程优雅许多？

初学Netty的时候，由于大部分人对NIO编程缺乏经验，因此，将Netty里面的概念与IO模型结合起来可能更好理解

1.`boos`对应，`IOServer.java`中的接受新连接线程，主要负责创建新连接
 2.`worker`对应 `IOClient.java`中的负责读取数据的线程，主要用于读取数据以及业务逻辑处理

****

**Netty解决了传统IO效率低下耗费资源的问题，解决了NIO代码复杂晦涩难懂的问题，而且还能随时在IO和NIO之间切换**

## 4、Netty实践，使用Netty实现一个简单的HTTP服务器和springmv注解

在开发web应用的时候，截止2019年大多数人采用的还是servlet规范的那一套来开发的，比如springmvc。虽然在2018年Java程序员们可以选择使用spring5中的webflux，但是这个转变没那么快。然而，基于servlet那一套的springmvc性能很差，如果你厌烦了，你大可以使用netty来实现一个web框架。假设你想使用netty来实现，那么第一步你得会使用Netty启动一个HTTP服务器，下面开始吧。

为了演示如何使用Netty来实现一个HTTP服务器，如果要实现一个完整的，那将是十分复杂的。所以，我们只实现最基本的，请求-响应。具体来说是这样的：

```
1. 启动服务
2. 输入请求可以跳转页面
3、输入请求可以返回json
```



## 5、Netty实践——WebFlux

Spring WebFlux是随Spring 5推出的响应式Web框架

![](https://img-blog.csdn.net/20171114215628516)

 Spring WebFlux 肯基于 Rea I 和 Servlet 3.1+ 容器设计的响应式编程框架