# 类设计

## 1、面向对象的三个基本特征

​	面向对象的三个基本特征分别为**封装、继承、多态**



![1](http://bed.thunisoft.com:9000/ibed/2019/05/26/9c53a6821cf74e7a97488d1d404a5f14.gif)

- ### 抽象与封装

  抽象是把系统中需要处理的数据和在这些数据上的操作结合在一起，根据功能、性质和用途等因素抽象成不同的抽象数据类型。每个抽象数据类型既包含了数据，又包含了针对这些数据的授权操作。在面向对象的程序设计中，抽象数据类型是用“类”这种结构来实现的，每个类里都封装了相关的数据和操作。封装是指利用抽象数据类型和基于数据的操作结合在一起，数据被保护在抽象数据类型的内部，系统的其他部分只有通过包裹在数据之外被授权的操作，才能与这个抽象数据类型进行交互。

 

- ### 继承

  面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

  通过继承创建的新类称为“子类”或“派生类”。

  被继承的类称为“基类”、“父类”或“超类”。

  继承的过程，就是从一般到特殊的过程。

  要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。

  在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

   

  继承概念的实现方式有三类：实现继承、接口继承和可视继承。

  Ø         实现继承是指使用基类的属性和方法而无需额外编码的能力；

  Ø         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

  Ø         可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。

  在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。

  抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 Interface 而不是 Class。

  OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。

 

- ### 多态

  多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：**允许将子类类型的指针赋值给父类类型的指针**。

  实现多态，有二种方式，覆盖，重载。

  - 覆盖，是指子类重新定义父类的虚函数的做法。
  - 重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。”

  那么，多态的作用是什么呢？

  我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。

  

## 2、面向对象设计原则：

​	面向对象设计需要解决的核心问题之一：如何同时提高一个软件系统的可维护性和可复用性？



- ##### 单一职责原则(Single Responsibility Principle)：一个类只负责一个功能领域中的相应职责，或者定义为：一个类应该只有一个引起它变化的原因。单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则。单一职责原则可以看作是高内聚、低耦合在面向对象原则上的引申。类的职责过多，容易导致类间职责依赖，提高耦合度，降低内聚性。通常意义下的单一职责，指的是类只有一种单一功能，不要为类设计过多的功能，交杂不清的功能会使代码杂乱，提高程序开发的难度和系统出错的概率，降低系统的可维护性



- ##### 开闭原则(Open-Closed Principle)：一个软件实体应对实体扩展开放，而对修改关闭，即软件实体应尽量在不修改原有代码的情况下进行扩展。所谓修改关闭，就是之前设计好的类，不要去修改。比如删除掉一个成员函数、改变成员函数的形参列表或更改数据成员类型等。实现对修改封闭，关键在于抽象化。对一个事物抽象化，实质上是对一个事物进行概括、归纳、总结，将其本质特征抽象地用一个类来表示，这样类才会相对稳定，无需更改



- ##### 里斯替换原则(Liskov Substitution Principle):所有引用基类对象的地方，可以透明的使用其子类的对象。里氏代换原则是实现开闭原则的重要方式之一。



- ##### 依赖倒置原则(Dependence Inversion Principle):抽象不依赖于细节，细节应该依赖于抽象。上层依赖于下层，下层不依赖于上层。换言之，要针对接口编程，而不是针对实现编程。依赖一定存在于类与类、模块与模块之间。类与类之间产生依赖时，依赖倒置原则的理解可以描述如下：依赖就是刚开始时具体细节间互相依赖，我们将实现的细节变成抽象类，降低类间耦合度。然后有了抽象类，继承自它的实现类也要依赖它。那倒置两字咋理解呢? 一般情况我们是先关注细节，然后根据细节抽象出来一些概括的方法，所以按常理一般是抽象要依赖于细节的，而现在是是倒过来了,确定一个抽象类后，那些细节的实现得以抽象出来的方法为基准，变成了细节依赖于抽象了，不然你要继承了一个抽象类，你不完全实现它的方法的话可不让你实例化对象的啊。

  

- ##### 接口隔离原则(Interface Segregation Principle)：使用多个专门的接口，而不使用单一的总接口。即客户端不应该依赖那些不需要的接口。  该原则的核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。具体而言，接口应该是内聚的，应该避免“胖”接口。一个类对另一个类的依赖应该建立在最小的接口上，而不要强迫依赖不同的方法，这是一种接口污染。其实简单点的讲与前面说的单一职责类似，这里的接口不是函数接口，而是一个类。在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口违背接口隔离原则，灵活性较差，使用起来不是很方便。



- ##### 合成复用原则又称为组合/聚合复用原则(Composite Reuse Principle):尽量使用对象组合，而不是继承来达到复用的目的。   两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承。  通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。



- ##### 迪米特法则又称为最少知识原则(Law of Demeter):一个软件实体应当尽可能少地与其他实体发生相互作用。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。  迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。

  

  ##### 总结：概括地讲，面向对象设计原则仍然是面向对象思想的体现。

  1、 单一职责原则要求类只负责一件事情。接口分离原则，让客户只关心他们所需的接口。单一职责原则与接口分离原都体现了内聚的思想； 
  2、开放封闭原则，要求类不作修改而能够扩展功能，体现了类的封装与继承； 
  3、Liskov替换原则，要求派生类要能够替换基类，是对类继承的规范； 
  4、依赖倒置原则，要求类依赖于抽象，而不是实现，是抽象思想的体现。

